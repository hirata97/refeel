name: PR Quality Summary

# PRå“è³ªãƒã‚§ãƒƒã‚¯ã®çµ±åˆã‚µãƒãƒªãƒ¼ç”Ÿæˆ
# ç›®çš„: Code Qualityã€Testingã€Securityã®çµæœã‚’é›†ç´„ã—ã¦PRã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿
on:
  workflow_run:
    workflows:
      - "PR Code Quality"
      - "PR Unit Tests (Vitest)"
      - "PR Security"
    types:
      - completed

# æ¨©é™è¨­å®š
permissions:
  contents: read
  pull-requests: write
  checks: read
  actions: read

jobs:
  quality-report:
    name: Quality Gate Summary
    runs-on: ubuntu-latest
    # PRã«é–¢é€£ã™ã‚‹å®Ÿè¡Œã®ã¿å‡¦ç†
    if: github.event.workflow_run.event == 'pull_request'

    steps:
    - name: Get PR number
      id: pr
      uses: actions/github-script@v7
      with:
        script: |
          const pulls = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`
          });

          if (pulls.data.length === 0) {
            console.log('No open PR found for this branch');
            return null;
          }

          const prNumber = pulls.data[0].number;
          core.setOutput('number', prNumber);
          return prNumber;

    - name: Get check runs status
      if: steps.pr.outputs.number
      id: checks
      uses: actions/github-script@v7
      with:
        script: |
          const prNumber = ${{ steps.pr.outputs.number }};
          const headSha = context.payload.workflow_run.head_sha;

          // å„ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œçµæœã‚’å–å¾—
          const checkRuns = await github.rest.checks.listForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: headSha,
            per_page: 100
          });

          // å„ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®çµæœã‚’æŠ½å‡º
          const workflows = {
            'Code Quality Checks': null,
            'Unit Tests (Vitest)': null,
            'Security Analysis': null
          };

          for (const run of checkRuns.data.check_runs) {
            if (run.name in workflows) {
              workflows[run.name] = run.conclusion;
            }
          }

          core.setOutput('code_quality', workflows['Code Quality Checks'] || 'pending');
          core.setOutput('testing', workflows['Unit Tests (Vitest)'] || 'pending');
          core.setOutput('security', workflows['Security Analysis'] || 'pending');

          return workflows;

    - name: Generate Quality Report
      if: steps.pr.outputs.number
      uses: actions/github-script@v7
      with:
        script: |
          const prNumber = ${{ steps.pr.outputs.number }};
          const codeQualityResult = '${{ steps.checks.outputs.code_quality }}';
          const testingResult = '${{ steps.checks.outputs.testing }}';
          const securityResult = '${{ steps.checks.outputs.security }}';

          // å…¨ã¦ã®ãƒã‚§ãƒƒã‚¯ãŒæˆåŠŸã—ãŸã‹åˆ¤å®š
          const allPassed = codeQualityResult === 'success' &&
                           testingResult === 'success' &&
                           securityResult === 'success';

          const status = allPassed ? 'âœ… å“è³ªã‚²ãƒ¼ãƒˆé€šé' : 'âŒ å“è³ªã‚²ãƒ¼ãƒˆå¤±æ•—';

          // çµæœã‚¢ã‚¤ã‚³ãƒ³ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
          const getIcon = (result) => {
            if (result === 'success') return 'âœ…';
            if (result === 'failure') return 'âŒ';
            if (result === 'skipped') return 'â­ï¸';
            if (result === 'pending') return 'â³';
            return 'âš ï¸';
          };

          let report = `## ${status}\n\n`;
          report += '### ğŸ“Š ãƒã‚§ãƒƒã‚¯çµæœ\n\n';
          report += `${getIcon(codeQualityResult)} **Code Quality**: ${codeQualityResult}\n`;
          report += `${getIcon(testingResult)} **Testing**: ${testingResult}\n`;
          report += `${getIcon(securityResult)} **Security**: ${securityResult}\n`;

          report += '\n### ğŸ“‹ å“è³ªåŸºæº–\n';
          report += '#### å¿…é ˆãƒ¬ãƒ™ãƒ«ï¼ˆPRãƒãƒ¼ã‚¸æ¡ä»¶ï¼‰\n';
          report += '- âœ… **ESLint**: ã‚¨ãƒ©ãƒ¼0ä»¶å¿…é ˆï¼ˆè­¦å‘Šã¯è¨±å®¹ï¼‰\n';
          report += '- âœ… **TypeScript**: å‹ã‚¨ãƒ©ãƒ¼0ä»¶å¿…é ˆ\n';
          report += '- âœ… **Prettier**: ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæº–æ‹ å¿…é ˆ\n';
          report += '- âœ… **ãƒ“ãƒ«ãƒ‰**: æœ¬ç•ªãƒ“ãƒ«ãƒ‰æˆåŠŸå¿…é ˆ\n';
          report += '- âœ… **ãƒ†ã‚¹ãƒˆ**: å…¨ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆæˆåŠŸå¿…é ˆ\n';
          report += '- âœ… **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: High/Criticalè„†å¼±æ€§0ä»¶å¿…é ˆ\n\n';

          report += '#### æ¨å¥¨ãƒ¬ãƒ™ãƒ«ï¼ˆè­¦å‘Šè¡¨ç¤ºï¼‰\n';
          report += '- ğŸ“Š **ã‚«ãƒãƒ¬ãƒƒã‚¸**: 70%ä»¥ä¸Šæ¨å¥¨ï¼ˆç¾åœ¨ç›£è¦–ä¸­ï¼‰\n';
          report += '- ğŸ”’ **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: Moderateä»¥ä¸‹ã®è„†å¼±æ€§å¯¾å¿œæ¨å¥¨\n\n';

          if (!allPassed) {
            report += '### âš ï¸ ãƒãƒ¼ã‚¸å‰ã«ä¸Šè¨˜ã®å•é¡Œã‚’è§£æ±ºã—ã¦ãã ã•ã„\n\n';
            report += '#### å¤±æ•—ã—ãŸãƒã‚§ãƒƒã‚¯è©³ç´°\n';
            if (codeQualityResult !== 'success') {
              report += '- **Code Quality**: ESLintã€TypeScriptã€ã¾ãŸã¯ãƒ“ãƒ«ãƒ‰ã«å•é¡ŒãŒã‚ã‚Šã¾ã™\n';
            }
            if (testingResult !== 'success') {
              report += '- **Testing**: ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã—ã¦ã„ã¾ã™\n';
            }
            if (securityResult !== 'success') {
              report += '- **Security**: é«˜ãƒªã‚¹ã‚¯ä»¥ä¸Šã®è„†å¼±æ€§ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã¾ã™\n';
            }
          } else {
            report += '### ğŸ‰ ã™ã¹ã¦ã®å“è³ªãƒã‚§ãƒƒã‚¯ã«åˆæ ¼ã—ã¦ã„ã¾ã™ï¼\n';
            report += '\nå®‰å¿ƒã—ã¦ãƒãƒ¼ã‚¸ã§ãã¾ã™ã€‚ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼\n';
          }

          // æ—¢å­˜ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ¤œç´¢
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: prNumber
          });

          const botComment = comments.data.find(comment =>
            comment.user.type === 'Bot' &&
            comment.body.includes('å“è³ªã‚²ãƒ¼ãƒˆ')
          );

          // ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ›´æ–°ã¾ãŸã¯ä½œæˆ
          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: report
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: report
            });
          }
